# 프로토버퍼 공부 (Protocol Buffers r&d)

## 프로토버퍼

JSON과 비슷하지만 더욱 작고, 빠르고, 언어에 맞는 바인딩을 생성함.
직접 데이터 구조를 정의한 뒤, 생성된 소스 코드를 통해 쉽게 구조화된 데이터를 입출력하고,
다양한 데이터 스트림을 다양한 언어를 사용할 수 있음.

프로토버퍼는 definition language의 조합임.
프로토 컴파일러가 데이터와 상호작용하기 위해 생성하는 언어별 런타임 라이브러리, 데이터 직렬화 형식은 파일로 작성됨 (또는 네트워크 연결로 보내짐)

## 프로토버퍼가 해결하는 문제들

1. 타입, 구조화된 데이터를 몇 메가바이트 사이즈로 직렬화 시킴.
   이는 일시적인 네트워크 통신이나 장시간 데이터 보관 둘다 용이함.

2. 프로토버퍼는 기존 데이터를 무효화하거나, 기존 코드를 최신화 할 필요 없이 확장이 가능함.

프로토버퍼는 Google에서 가장 흔하게 사용되는 데이터 형식이고,
서버 간 의사소통과 디스크에 데이터 보관에 널리 사용됨.
프로토버퍼 *messages*와 *services*는 아래의 예시와 같이 `.proto` 파일에 엔지니어가 작성함.

```proto
// Person.proto

message Person {
    optional string name = 1;
    optional int32 id = 2;
    optional string email = 3;
}
```

프로토 컴파일러는 빌드 단계에서 `.proto` 파일을 다양한 프로그래밍 언어 코드가 해당하는 프로토버퍼를 조작할 수 있게 호출됨.
각각의 생성된 클레스는, 각각의 필드에 접근하는 간단한 접근자와, 구조 전부를 raw 바이트로 직렬화 하는 메소드와, raw 바이트에서 구조에 맞게 파싱하는 메소드를 가짐.
아래의 예시는 생성된 메소드들을 사용하는 방식을 보여줌.

```java
Person han = Person.newBuilder()
    .setId(225)
    .setName("Wooyeop Han")
    .setEmail("wooyeophan@gmail.com")
    .build();
output = new FileOutputStream(args[0]);
han.writeTo(output)
```

프로토버퍼는 모든 구글 서비스에 널리 사용되고, 이들의 데이터는 오랜 시간 동안 존재할 수 있기 때문에, 호환성을 유지하는건 매우 중요함. 프로토버퍼는 변경 사항에 대한 원할한 대응을 허용함.
모든 프로토버퍼에 대한 새로운 필드의 추가와, 존재하는 필드의 삭제는 기존 서비스에 영향을 주지 않음.

## 프로토버퍼로 인한 이점

프로토버퍼는, 구조화, 레코드, 타입 있는 데이터를 언어, 플렛폼 중립적, 확장성 있게 직렬화 해야 하는 경우에 최적임. 통신 프로토콜 정의, 데이터 저장에 주로 사용됨.

프로토버퍼를 통해 얻는 몇몇 이점중 일부는 아래와 같음
* 밀집된 데이터 저장
* 빠른 파싱
* 다양한 프로그래밍 언어에서의 지원
* 자동으로 생성된 클래스를 통한 최적화된 기능성

### Cross-language 호환성

지원되는 프로그래밍 언어로 작성된 코드로 동일한 메세지를 읽을 수 있음.
한 플렛폼에선 소프트웨어 시스템의 데이터를 잡고, `.proto` 정의를 기반으로 직렬화를 하는 Java 프로그램이 있고, 다른 플렛폼에서 직렬화된 특정한 값을 추출하는 파이썬 애플리케이션이 존재할 수 있음.

아래의 언어들은 프로토버퍼 컴파일러에서 바로 지원됨, protoc:
* C++
* C#
* Java
* Kotlin
* Objective-C
* PHP
* Python
* Ruby

아래의 언어는 Google에서 지원하지만, 프로젝트의 소스 코드는 GitHub 레포지트리에 존재함. protoc 컴파일러는 아래의 언어를 플러그인을 통해 지원함.
* Dart
* Go

추가적인 언어는 Google을 통해 직접적으로 지원되지는 않지만, 별도의 GitHub 프로젝트들을 통해 지원됨.

### 코드를 최신화하지 않고 프로토 정의를 최신화

소프트웨어 제품이 호환성을 가지는 것은 기본적인 것임, 하지만 향후 호환성을 가지는 것은 별로 흔하지 않음. `.proto` 정의를 최신화 할 때 [간단한 관행](https://protobuf.dev/programming-guides/proto3/#updating)을 따른다면, 과거의 코드는 새로 추가된 필드를 무시하고, 문제 없이 메세지를 읽을 것임. 삭제된 필드의 경우, 과거의 코드는 이의 기본값, 반복되는 데이터의 나열은 빈 값으로 처리됨.

새 코드도 과거의 메세지를 손쉽게 읽음. 새롭게 추가된 필드는 과거의 메세지에서 존재하지 않고, 프로토버퍼에서 기본값을 제공함.

### 프로토버퍼가 사용되기 좋지 못한 상황

프로토버퍼는 모든 데이터에 만족되지는 않음. 예를 들어:
* 프로토버퍼는 메세지 전채가 한번에 메모리에 로드될 수 있고, [오브젝트 그래프](https://stackoverflow.com/questions/2046761/what-is-object-graph-in-java)보다 크지 않다고 가정함.
약간의 메가바이트를 넘어서는 데이터에 경우, 다른 해결책을 사용하길 권장함.
큰 데이터를 다루는 경우, 직렬화된 복사본으로 인해, 여러개의 데이터 복사본이 생길 수 있고, 이는 메모리 사용량이 갑자기 급증할 수 있음.
* 프로토버퍼가 직렬화된 뒤, 같은 데이터는 다른 바이너리 직렬화를 가질 수 있음. 전부 파싱하지 않고선 두 메세지가 같은지 비교할 수 있음.
* 메세지는 압축되지 않음. 이는 다른 파일처럼 압축되거나 gzip될 수 있지만, 적절한 타입에 해당하는 특별한 압축 알고리즘; 예를 들어 JPEG와 PNG는 더욱 작은 파일을 생성하게 됨.
* 프로토버퍼 메세지는 많은 과학, 엔지니어링 분야에서 사용되는 부동 소수점으로 이루어진 크고 여러 차원의 배열에 한해서 크기와 속도 둘다 최대 효율을 내지 못함. 이러한 에플리케이션은, [FITS](https://en.wikipedia.org/wiki/FITS)와 비슷한 형식이 적은 오버헤드를 남김.
* 프로토버퍼는 과학 컴퓨팅에서 주로 사용되는 Fortran, IDL 처럼 non-object-oriented 언어에는 잘 지원되지 않음.
* 프로토버퍼 메시지는 본질적으로 데이터를 자제적으로 설명하지 않음, 하지만 완벽하게 일치되는 스키마가 존재한다면, 자체적 설명을 구현할 수 있음. 이는, 해당하는 `.proto` 파일 없이는 전부 해석하지 못한다는 것을 의미함.
* 프로토버퍼는 어떠한 조직의 공식적인 표준이 아님. 이는 법적이나 다른 요청으로 인하여 표준으로 구축해야 하는 환경에서 사용하기 부적합함.

## 프로토버퍼의 동작

아레의 다이어그램은 프로토버퍼를 통해 데이터를 작업하는 과정을 나타냄.

![프로토버퍼 동작 다이어그램](https://protobuf.dev/images/protocol-buffers-concepts.png)
**그림 1. 프로토버퍼 동작 흐름**

프로토버퍼를 통해 생성된 코드는 파일과 스트림에서 데이터를 받아올 수 있는 유틸리티 메소드들을 제공함, 각각의 값들을 데이터에서 추출, 데이터가 있는지 확인, 데이터를 다시 파일이나 스트림으로 직렬화하는 등의 유용한 함수들로 이루어짐.

아래의 코드는 위의 흐름을 Java로 표현함. 앞서 보인것과 같이, `.proto` 정의는 다음과 같음:

```proto
message Person {
    optional string name = 1;
    optional int32 id = 2;
    optional string email = 3;
}
```

이 `.proto` 파일을 컴파일하게 되면, 새로운 인스턴스를 생성할 수 있는 `Builder` 클래스를 생성함. 아래의 Java 코드에서 이를 나태냄.

```java
Person han = Person.newBuilder()
    .setId(225)
    .setName("Wooyeop Han")
    .setEmail("wooyeophan@gmail.com")
    .build();
output = new FileOutputStream(args[0]);
han.writeTo(output);
```

그리고 프로토버퍼가 생성한 메소드를 통해 다른 언어에서 역직렬화 또한 가능함. 아래의 C++ 코드에서 이를 나타냄.

```cpp
Person han;
fstream input(argv[1], ios::in | ios::binary);
han.ParseFromIstream(&input);
int id = han.id();                  // 225
std::string name = han.name();      // "Wooyeop Han"
std::string email = han.email();    // "wooyeophan@gmail.com"
```

## 프로토버퍼 정의 문법

`.proto` 파일을 정의할 때, 필드를 `optional` 인지 `repeated` 인지 지정하거나, proto3 의 기본값인 암시적 존재로 설정할 수 있음. (필드를 `required`로 설정하는 옵션은 proto3에선 존지하지 않고, proto2에선 강력하게 권장하지 않음.)

필드의 선택성/반복성을 지정한 뒤, 데이터 타입을 지정함. 프로토버퍼는 일반적인 기본 데이터 유형, 예를 들어 정수, 부울, 부동 소수점 등을 지원함. 지원되는 전채 유형은 [Scalar Value Types](https://protobuf.dev/programming-guides/proto3/#scalar)에 표기되어 있음.

필드는 이와 같을 수 있음:
* `message` 타입: 반복되는 데이터 세트와 같이 정의의 일부를 중첩.
* `enum` 타입: 값들의 집합 중 하나를 선택.
* `oneof` 타입: 메세지가 많은 선택성 필드를 가졌지만, 하나의 필드만 선택되야 하는 경우.
* `map` 타입: key-value 쌍을 정의에 포함.

필드의 옵션과 타입을 선택한 뒤, 필드의 이름을 선택함. 필드의 이름을 설정할 경우, 고려해야 할 사항이 있음:
* 프로덕션에서 사용된 뒤에는 필드 이름 변경이 힘들거나 불가능 할 수 있음.
* 필드 이름은 dash (`-`) 를 포함할 수 없음. 필드 이름 문법은 [Message and Field Names](https://protobuf.dev/programming-guides/style/#message-field-names)에 표기되어 있음.
* 반복되는 필드의 경우, 복수형 이름을 사용.

필드에 이름을 지정한 뒤, 필드 번호를 지정함. 필드 번호는 용도 변경과 재사용이 불가능함. 필드를 삭제한 경우, 누군가가 필드 번호를 재사용하지 않게 예약해 두어야 함.

## 추가적인 데이터 형식 지원

프로토버퍼는 다양한 스칼라 값 타입을 지원함. 가변 길이 인코딩과 고정 사이즈 정수 또한 지원됨.
필드에 할당 가능한 데이터 유형인 메세지를 정의하여 자신만의 합성 데이터 타입을 생성할 수도 있음.
단순 및 복합 값 유형 외에도, 몇몇 [공통 타입](https://protobuf.dev/programming-guides/dos-donts/#common)이 게시되어 있음.